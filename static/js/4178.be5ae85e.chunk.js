"use strict";(self.webpackChunkdashboard=self.webpackChunkdashboard||[]).push([[4178],{84178:(n,t,r)=>{r.d(t,{CJ:()=>W,Cz:()=>U,D$:()=>I,ED:()=>k,FH:()=>j,G0:()=>z,Gg:()=>b,JI:()=>E,LV:()=>S,Nm:()=>x,Sp:()=>O,TE:()=>v,U1:()=>H,W4:()=>m,Y4:()=>B,_L:()=>G,cv:()=>D,e5:()=>N,f3:()=>L,fS:()=>g,intersect:()=>C,j2:()=>V,jU:()=>p,kK:()=>h,kQ:()=>F,og:()=>J,oq:()=>d,r3:()=>w,rd:()=>R,sz:()=>Z,uh:()=>A,z7:()=>y});r(59486);var e=r(70431),i=r(585),a=r(77981);function u(n){var t;return Array.isArray(n)?null===(t=n[0])||void 0===t?void 0:t.spatialReference:null===n||void 0===n?void 0:n.spatialReference}function o(n){return n?Array.isArray(n)?n.map(o):n.toJSON?n.toJSON():n:n}function c(n){return Array.isArray(n)?n.map((n=>(0,a.im)(n))):(0,a.im)(n)}let s;async function f(){return s||(s=(0,e.bA)("geometryEngineWorker",{strategy:"distributed"})),s}async function l(n,t){return(await f()).invoke("executeGEOperation",{operation:n,parameters:o(t)})}async function d(n,t){return c(await l("clip",[u(n),n,t]))}async function y(n,t){return c(await l("cut",[u(n),n,t]))}function w(n,t){return l("contains",[u(n),n,t])}function p(n,t){return l("crosses",[u(n),n,t])}function v(n,t,r){return l("distance",[u(n),n,t,r])}function g(n,t){return l("equals",[u(n),n,t])}function h(n,t){return l("intersects",[u(n),n,t])}function m(n,t){return l("touches",[u(n),n,t])}function A(n,t){return l("within",[u(n),n,t])}function k(n,t){return l("disjoint",[u(n),n,t])}function x(n,t){return l("overlaps",[u(n),n,t])}function S(n,t,r){return l("relate",[u(n),n,t,r])}function b(n){return l("isSimple",[u(n),n])}async function J(n){return c(await l("simplify",[u(n),n]))}async function E(n){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return c(await l("convexHull",[u(n),n,t]))}async function N(n,t){return c(await l("difference",[u(n),n,t]))}async function O(n,t){return c(await l("symmetricDifference",[u(n),n,t]))}async function C(n,t){return c(await l("intersect",[u(n),n,t]))}async function z(n){const t=function(n,t){let r;return Array.isArray(n)?r=n:(r=[],r.push(n),null!=t&&r.push(t)),r}(n,arguments.length>1&&void 0!==arguments[1]?arguments[1]:null);return c(await l("union",[u(t),t]))}async function D(n,t,r,e,i,a){return c(await l("offset",[u(n),n,t,r,e,i,a]))}async function L(n,t,r){let e=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const i=[u(n),n,t,r,e];return c(await l("buffer",i))}async function R(n,t,r,e,i,a){const o=[u(n),n,t,r,e,i,a];return c(await l("geodesicBuffer",o))}async function j(n,t){let r=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const e=await l("nearestCoordinate",[u(n),n,t,r]);return{...e,coordinate:i.Z.fromJSON(e.coordinate)}}async function G(n,t){const r=await l("nearestVertex",[u(n),n,t]);return{...r,coordinate:i.Z.fromJSON(r.coordinate)}}function q(n){var t;return"xmin"in n?n.center:"x"in n?n:null===(t=n.extent)||void 0===t?void 0:t.center}async function H(n,t,r){var e;if(null==n)throw new K;const i=n.spatialReference;if(null==(r=null!==(e=r)&&void 0!==e?e:q(n)))throw new K;const a=n.constructor.fromJSON(await l("rotate",[i,n,t,r]));return a.spatialReference=i,a}async function I(n,t,r,e){return c(await l("generalize",[u(n),n,t,r,e]))}async function U(n,t,r){return c(await l("densify",[u(n),n,t,r]))}async function V(n,t,r){let e=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;return c(await l("geodesicDensify",[u(n),n,t,r,e]))}function W(n,t){return l("planarArea",[u(n),n,t])}function Z(n,t){return l("planarLength",[u(n),n,t])}function B(n,t,r){return l("geodesicArea",[u(n),n,t,r])}function F(n,t,r){return l("geodesicLength",[u(n),n,t,r])}class K extends Error{constructor(){super("Illegal Argument Exception")}}}}]);
//# sourceMappingURL=4178.be5ae85e.chunk.js.map